# -*- coding: utf-8 -*-
# Copyright (c) 2020-2024 Salvador E. Tropea
# Copyright (c) 2020-2024 Instituto Nacional de Tecnolog√≠a Industrial
# License: AGPL-3.0
# Project: KiBot (formerly KiPlot)
# https://gitlab.com/kicad/code/kicad/-/blob/master/resources/schemas/erc.v1.json?ref_type=heads
import csv
import io
import json
import os
from . import __version__
from .bom.kibot_logo import KIBOT_LOGO, KIBOT_LOGO_W, KIBOT_LOGO_H
from .macros import macros, document, pre_class  # noqa: F401
from .gs import GS
from .optionable import Optionable
from .kiplot import load_sch, run_command
from .error import KiPlotConfigurationError
from .misc import (ERC_ERROR, W_ERCJSON, STYLE_COMMON, TABLE_MODERN, HEAD_COLOR_B, HEAD_COLOR_B_L, TD_ERC_CLASSES,
                   GENERATOR_CSS, W_ERC)
from .log import get_logger
logger = get_logger(__name__)


def warning(msg):
    logger.warning(W_ERC+msg)


class ERCOptions(Optionable):
    """ ERC options """
    def __init__(self):
        with document:
            self.enabled = True
            """ Enable the ERC. This is the replacement for the boolean value """
            self.dir = ''
            """ Sub-directory for the report """
            self.output = GS.def_global_output
            """ *Name for the generated archive (%i=erc %x=according to format) """
            self.format = Optionable
            """ [string|list(string)='HTML'][RPT,HTML,CSV,JSON] Format/s used for the report.
                You can specify multiple formats """
            self.warnings_as_errors = False
            """ ERC warnings are considered errors, they still reported as errors, but consider it an error """
            self.dont_stop = False
            """ Continue even if we detect ERC errors """
        super().__init__()
        self._unknown_is_error = True
        self._format_example = 'HTML,RPT'

    def config(self, parent):
        super().config(parent)
        self.format = Optionable.force_list(self.format)
        if not self.format:
            self.format = ['HTML']
        for f in self.format:
            if f not in {'RPT', 'HTML', 'CSV', 'JSON'}:
                raise KiPlotConfigurationError(f'unkwnown format `{f}`')


@pre_class
class ERC(BasePreFlight):  # noqa: F821
    """ [boolean=false|dict] Runs the ERC (Electrical Rules Check). To ensure the schematic is electrically correct.
        This is a replacement for the *run_erc* preflight that needs KiCad 8 or newer """
    def __init__(self, name, value):
        super().__init__(name, value)
        if isinstance(value, bool):
            f = ERCOptions()
            f.enabled = value
            f.format = ['HTML']
        elif isinstance(value, dict):
            f = ERCOptions()
            f.set_tree(value)
            f.config(self)
        else:
            raise KiPlotConfigurationError('must be boolean or dict')
        # Transfer the options to this class
        for k, v in dict(f.get_attrs_gen()).items():
            setattr(self, '_'+k, v)
        self._format = f.format
        self._sch_related = True
        self._expand_id = 'erc'
        self._expand_ext = self._format[0].lower()

    def get_targets(self):
        """ Returns a list of targets generated by this preflight """
        load_sch()
        out_dir = self.expand_dirname(GS.out_dir)
        if GS.global_dir and GS.global_use_dir_for_preflights:
            out_dir = os.path.join(out_dir, self.expand_dirname(GS.global_dir))
        names = []
        for f in self._format:
            self._expand_ext = f.lower()
            name = Optionable.expand_filename_sch(self, self._output)
            names.append(os.path.abspath(os.path.join(out_dir, self._dir, name)))
        return names

    @classmethod
    def get_doc(cls):
        return cls.__doc__, ERCOptions

    def get_item_txt(self, item, indent=4, sep='\n'):
        desc = item.get('description', '')
        pos = item.get('pos', None)
        if pos:
            x = pos.get('x', 0)
            y = pos.get('y', 0)
            pos_txt = f'@({x} {self.units}, {y} {self.units}): '
        else:
            pos_txt = ''
        return (' '*indent)+f'{pos_txt}{desc}'+sep

    def apply_filters(self, data):
        GS.filters if GS.filters else []
        self.c_err = self.c_warn = self.c_tot = 0
        self.c_err_excl = self.c_warn_excl = self.c_tot_excl = 0
        sheets = data.get('sheets', [])
        for sheet in sheets:
            violations = sheet.get('violations', [])
            for violation in violations:
                severity = violation.get('severity', 'error')
                if violation.get('excluded'):
                    # Already filtered inside KiCad
                    if severity == 'error':
                        self.c_err_excl += 1
                    else:
                        self.c_warn_excl += 1
                    self.c_tot_excl += 1
                    continue
                type = violation.get('type', '')
                # Collect the text using a layout equivalent to the report
                txt = violation.get('description', '')+'\n'
                for item in violation.get('items', []):
                    txt += self.get_item_txt(item)
                # Check if any filter matches this violation
                excluded = False
                for f in GS.filters:
                    if type == f.error and f.regex.search(txt):
                        violation['excluded'] = True
                        violation['excluded_by_kibot'] = True
                        excluded = True
                        break
                if excluded:
                    if severity == 'error':
                        self.c_err_excl += 1
                    else:
                        self.c_warn_excl += 1
                    self.c_tot_excl += 1
                else:
                    if severity == 'error':
                        self.c_err += 1
                    else:
                        self.c_warn += 1
                    self.c_tot += 1

    def create_csv(self, data):
        f = io.StringIO()
        writer = csv.writer(f, delimiter=',', lineterminator="\n", quoting=csv.QUOTE_ALL)
        writer.writerow(['Sheet', 'Severity', 'Excluded', 'Type', 'Description', 'Details'])
        sheets = data.get('sheets', [])
        for sheet in sheets:
            violations = sheet.get('violations', [])
            sheet_name = sheet.get('path', '')
            for violation in violations:
                severity = violation.get('severity', 'error')
                excluded = violation.get('excluded', False)
                type = violation.get('type', '')
                description = violation.get('description', '')
                details = ''
                for item in violation.get('items', []):
                    details += self.get_item_txt(item, indent=0, sep=';')
                writer.writerow([sheet_name, severity, excluded, type, description, details[:-1]])
        return f.getvalue()

    def add_html_violation(self, violation, html, i):
        severity = violation.get('severity', 'error')
        excluded = violation.get('excluded', False)
        type = violation.get('type', '')
        description = violation.get('description', '')
        details = ''
        for item in violation.get('items', []):
            details += self.get_item_txt(item, indent=0, sep='<br>')
        html += f'  <tr id="{i}">\n'
        cl = 'td-excluded' if excluded else ('td-error' if severity == 'error' else 'td-warning')
        html += f'   <td class="{cl}">{type}</td>\n'
        html += f'   <td>{description}</td>\n'
        html += f'   <td>{details}</td>\n'
        html += '  </tr>\n'
        return html

    def create_html(self, data):
        # HTML Head
        html = '<html>\n'
        html += '<head>\n'
        html += ' <meta charset="UTF-8">\n'  # UTF-8 encoding for unicode support
        title = 'ERC report for '+(GS.pro_basename or GS.sch_basename or '')
        html += f' <title>{title}</title>\n'
        # CSS
        html += '<style>\n'
        style = STYLE_COMMON
        style += TABLE_MODERN.replace('@bg@', HEAD_COLOR_B)
        style += TABLE_MODERN.replace('@bgl@', HEAD_COLOR_B_L)
        style += TD_ERC_CLASSES
        style += GENERATOR_CSS
        style += ' .head-table { margin-left: auto; margin-right: auto; }\n'
        style += ' .content-table { margin-left: auto; margin-right: auto }\n'
        html += style
        html += '</style>\n'
        html += '</head>\n'
        html += '<body>\n'

        img = 'data:image/png;base64,'+KIBOT_LOGO
        img_w = KIBOT_LOGO_W
        img_h = KIBOT_LOGO_H
        html += '<table class="head-table">\n'
        html += '<tr>\n'
        html += ' <td rowspan="3">\n'
        html += f'  <img src="{img}" alt="Logo" width="{img_w}" height="{img_h}">\n'
        html += ' </td>\n'
        html += ' <td colspan="2" class="cell-title">\n'
        html += f'  <div class="title">{title}</div>\n'
        html += ' </td>\n'
        html += '</tr>\n'
        html += '<tr>\n'
        html += ' <td class="cell-info">\n'
        html += f'   <b>Schematic</b>: {GS.sch_basename}<br>\n'
        html += f'   <b>Revision</b>: {GS.sch.revision}<br>\n'
        dt = data.get('date', '??')
        html += f'   <b>Date</b>: {dt}<br>\n'
        kv = data.get('kicad_version', GS.kicad_version)
        html += f'   <b>KiCad Version</b>: {kv}<br>\n'
        html += ' </td>\n'
        html += ' <td class="cell-stats">\n'
        txt_error = f'<b>Errors</b>: {self.c_err}'+(f' (+{self.c_err_excl} excluded)' if self.c_err_excl else '')
        txt_warn = f'<b>Warnings</b>: {self.c_warn}'+(f' (+{self.c_warn_excl} excluded)' if self.c_warn_excl else '')
        txt_total = f'<b>Total</b>: {self.c_tot}'+(f' (+{self.c_tot_excl} excluded)' if self.c_tot_excl else '')
        html += f'   {txt_error}<br>\n'
        html += f'   {txt_warn}<br>\n'
        html += f'   {txt_total}<br>\n'
        html += ' </td>\n'
        html += '</tr>\n'
        html += '</table>\n'

        sheets = data.get('sheets', [])
        i = 0
        # Generate the content
        for sheet in sheets:
            violations = sheet.get('violations', [])
            if not violations:
                continue
            sheet_name = sheet.get('path', '')
            html += f'<p class="subtitle">Sheet {sheet_name}</p>\n'
            html += '<table class="content-table">\n'
            html += ' <thead>\n'
            html += '  <tr>\n'
            for h in ['Type', 'Description', 'Details']:
                html += f'   <th>{h}</th>\n'
            html += '  </tr>\n'
            html += ' </thead>\n'
            html += ' <tbody>\n'
            # Errors
            for violation in violations:
                if violation.get('severity', 'error') == 'error' and not violation.get('excluded', False):
                    html = self.add_html_violation(violation, html, i)
                    i += 1
            # Warnings
            for violation in violations:
                if violation.get('severity', 'error') == 'warning' and not violation.get('excluded', False):
                    html = self.add_html_violation(violation, html, i)
                    i += 1
            # Excluded
            for violation in violations:
                if violation.get('excluded', False):
                    html = self.add_html_violation(violation, html, i)
                    i += 1
            html += ' </tbody>\n'
            html += '</table>\n'
        html += ('<p class="generator">Generated by <a href="https://github.com/INTI-CMNB/KiBot/">KiBot</a> v{}</p>\n'.
                 format(__version__))
        html += '</body>\n'
        html += '</html>\n'
        return html

    def create_json(self, data):
        return json.dumps(data, indent=4)

    def create_txt(self, data):
        dt = data.get('date', '??')
        rpt = f"ERC report ({dt}, Encoding UTF8)\n\n"
        for s in data.get('sheets', []):
            path = s.get('path', '')
            rpt += f"***** Sheet {path}\n"
            for v in s.get('violations', []):
                severity = v.get('severity', 'error')
                type = v.get('type', '')
                description = v.get('description', '')
                rpt += f'[{type}]: {description}\n'
                excluded = ' (excluded)' if v.get('excluded') else ''
                rpt += f'    ; {severity}{excluded}\n'
                for item in v.get('items', []):
                    rpt += self.get_item_txt(item)
                rpt += '\n'
        rpt += f" ** ERC messages: {self.c_tot}  Errors {self.c_err}  Warnings {self.c_warn}\n"
        return rpt

    def report(self, kind, count, data):
        if not count:
            return
        logf = logger.error if kind == 'error' else warning
        logf(f'{count} ERC {kind}s detected')
        for s in data.get('sheets', []):
            path = s.get('path', '')
            for v in s.get('violations', []):
                if v.get('excluded'):
                    continue
                severity = v.get('severity', 'error')
                if severity != kind:
                    continue
                type = v.get('type', '')
                description = v.get('description', '')
                txt = f'({type}) {description}\n'
                for item in v.get('items', []):
                    txt += self.get_item_txt(item)
                txt += f'    Sheet: {path}'
                logf(txt)

    def run(self):
        if not GS.ki8:
            raise KiPlotConfigurationError('The `erc` preflight needs KiCad 8 or newer, use `run_erc` instead')
        # Compute the output name and make sure the path exists
        outputs = self.get_targets()
        output = outputs[0]
        os.makedirs(os.path.dirname(output), exist_ok=True)
        # Run the ERC from the CLI
        cmd = ['kicad-cli', 'sch', 'erc', '-o', output, '--format', 'json', '--severity-all', GS.sch_file]
        logger.info('- Running the ERC')
        run_command(cmd)
        # Read the result
        with open(output, 'rt') as f:
            raw = f.read()
            try:
                data = json.loads(raw)
            except json.decoder.JSONDecodeError:
                raise KiPlotConfigurationError(f"Corrupted ERC report `{output}`:\n{raw}")
        if data.get('$schema', '') != 'https://schemas.kicad.org/erc.v1.json':
            logger.warning(W_ERCJSON+'Unknown JSON schema, ERC might fail')
        self.units = data.get('coordinate_units', 'mm')
        # Apply KiBot filters
        self.apply_filters(data)
        # Generate the desired output format
        for (f, output) in zip(self._format, outputs):
            if f == 'CSV':
                res = self.create_csv(data)
            elif f == 'HTML':
                res = self.create_html(data)
            elif f == 'JSON':
                res = self.create_json(data)
            else:
                res = self.create_txt(data)
            # Write it to the output file
            with open(output, 'wt') as f:
                f.write(res)
        # Report the result
        self.report('error', self.c_err, data)
        self.report('warning', self.c_warn, data)
        # Check the final status
        error_level = 0 if self._dont_stop else ERC_ERROR
        if self.c_err:
            GS.exit_with_error(f'ERC errors: {self.c_err}', error_level)
        elif self.c_warn and (self._warnings_as_errors or BasePreFlight.get_option('erc_warnings')):  # noqa: F821
            GS.exit_with_error(f'ERC warnings: {self.c_warn}, promoted as errors', error_level)
